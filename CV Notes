http://www.ipo.spb.ru/journal/content/1991/Описание%20дескриптора%20осуществляющего%20категоризацию%20изображений%20с%20учетом%20геометрических%20структур%20по%20всем%20цветам.pdf
#http://d33.infospace.ru/d33_conf/sb2015t1/131-144.pdf
№https://libeldoc.bsuir.by/bitstream/123456789/25835/1/k_Lukashevich.pdf
#https://disser.spbu.ru/disser2/disser/Batyukov_Alexander_disser.pdf
https://newtechaudit.ru/obnaruzhenie-pryamyh/ обнаружение линий алгоритм Хафа
https://habr.com/ru/companies/otus/articles/745946/ Пример Хафа Питон
https://habr.com/ru/articles/208090/ статья 


public class SawingIntervalValidator : AbstractValidator<SawingInterval>
{
    public SawingIntervalValidator()
    {
        RuleFor(i => i.SawedCoreTo)
            .GreaterThan(i => i.SawedCoreFrom)
            .When(i => i.SawedCoreFrom != null && i.SawedCoreTo != null)
            .WithMessage("Верх должен быть больше низа интервала распиловки.")
            .WithState(m => new ModelState(nameof(m.SawedCoreTo), PropTypes.Body));

        // Или объединить в одно правило для обоих свойств
        RuleFor(i => i)
            .Must(i => i.SawedCoreFrom == null || i.SawedCoreTo == null || i.SawedCoreTo > i.SawedCoreFrom)
            .WithMessage("Верх должен быть больше низа интервала распиловки.")
            .WithState(m => new ModelState("", PropTypes.Body));
    }
}




ест


ь такой валидатор
[IgnoreRegistrationValidator]
public class SawingIntervalValidator : AbstractValidator<SawingInterval>
{
    public SawingIntervalValidator()
    {
        this.RuleFor(i => i.SawedCoreTo)
            .Must((i, to) => to == null || to > i.SawedCoreFrom)
            .WithMessage("Верх должен быть меньше низа интервала распиловки.")
            .WithState(m => new ModelState(nameof(m.SawedCoreTo), PropTypes.Body));

        this.RuleFor(i => i.SawedCoreFrom)
            .Must((i, from) => from == null || from < i.SawedCoreTo)
            .WithMessage("Низ должен быть больше верха интервала распиловки.")
            .WithState(m => new ModelState(nameof(m.SawedCoreFrom), PropTypes.Body));
    }
}

[IgnoreRegistrationValidator]
public class CoreSawingVariableModelValidator : AbstractValidator<CoreSawingVariableModel>
{
 
        this.RuleForEach(m => m.SawingIntervals)
            .SetValidator(itemValidator);

 
}

почему не проходит такой тест
 [Fact]
    public async Task Validate_should_return_expected_error_when_top_sawing_interval_greater_bottom()
    {
        // Arrange
        var expectedErrorMessage = "Верх должен быть меньше низа интервала распиловки.";
        var variableModel = new CoreSawingVariableModel();
        var sawingInterval = new SawingInterval {
            SawedCoreFrom = 5,
            SawedCoreTo  = 4,
        };
        variableModel.SawingIntervals.Add(sawingInterval);

        // Act
        var result = await validator.TestValidateAsync(variableModel);
    
        // Assert
        result.ShouldHaveAnyValidationError(x => x.SawingIntervals[0].SawedCoreFrom)
        .WithErrorMessage(expectedErrorMessage);

